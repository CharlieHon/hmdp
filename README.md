# hmdp

### 基于redis实现短信登录

Redis代替session需要考虑的问题：
- 选择合适的数据结构
- 选择合适的key（唯一性和方便获取）
- 设置有效期
- 选择合适的存储粒度（过滤掉敏感信息）

### 登录拦截器优化

## 缓存

### 缓存更新策略

1. 内存淘汰
2. 超时踢出
3. 主动更新

### 缓存穿透

**缓存穿透**是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会达到数据库。

常见的解决方案：
1. 缓存空对象
   - 优点：实现简单，维护方便
   - 缺点：额外的内存消耗；可能造成短期的不一致
2. 布隆过滤
   - 优点：内存占用较少，没有多余key
   - 缺点：实现复杂；存在误判可能
3. 其它
   - 增强id的复杂度，避免被猜测id规律
   - 做好数据的基础格式校验
   - 加强用户权限校验
   - 做好热点参数的限流

### 缓存雪崩

**缓存雪崩**是指在同一时段大量的缓存key调试失效或者redis服务宕机，导致大量请求达到数据库，带来巨大压力。

解决方案：
1. 给不同的key的ttl添加随机值
2. 利用redis集群提高服务的可用性
3. 给缓存业务条件降级限流策略
4. 给服务添加多级缓存

### 缓存击穿

**缓存击穿问题**也叫热点key问题，就是一个**高并发访问**并且**缓存重建服务比较较复杂**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击

常见的解决方法：
1. 互斥锁
2. 逻辑过期
   - 热点数据提前导入
   - 本例中使用测试代码实现

### 封装redis工具类

## 优惠卷秒杀

### 全局唯一ID生成策略

- UUID
- Redis自增
- snowflake算法
- 数据库自增

Redis自增ID策略：
- 每天一个key，方便统计统计订单量
- ID构造：时间戳+计数器

### 乐观锁解决超卖问题


### 一人一单

### 事务失效问题

## 基于redis自定义分布式锁

### 分布式锁误删问题

添加线程标识+删除时先判断线程标识

### 分布式锁释放原子性问题

- 因为相同用户购买相同优惠券的key是相同的 `lock:order:userId:couponId` 通过设置不同的value，并在删除前进行判断可以防止误删
- 但是使用java编码，判断和删除操作非原子性。可能在判断时成功，但是由于某种情况本线程1锁超时过期，其它线程2(同用户同优惠卷，即锁key相同)获取锁，此时
  本线程执行删除操作，就把其它线程2的锁给删除了！
- 使用lua脚本，保证锁判断和锁删除执行的原子性

### 基于redis分分布式锁优化

1. 不可重入
2. 不可重试
3. 超时重试
4. 主从一致性

## 基于redisson实现分布式锁

redisson可重入锁原理：
- 利用hash结构
- field为线程标识，value为当前线程冲入次数
- 获取锁的时候，判断是否持有锁，持有则重入次数+1
- 释放锁时，判断是否持有锁，持有则重入次数-1，如果冲入次数<=0，则删除锁
- 每次更新锁冲入次数时都会刷新锁的过期时间

### redisson分布式锁原理

- 可重入：
  - 利用hash结构记录线程id和重入次数
- 可重试：
  - 利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制
- 超时续约：
  - 利用watchDog，每隔一段时间(releaseTime / 3)，重置超时时长
  - 注意，只有当超时时间设置为-1时，才会开启watchDog机制

### redisson的multiLock

- 原理：利用多个独立的redis节点，必须在所有节点都获取冲入锁，才算获取成功
- 缺点：运维程本高，实现复杂

## 秒杀优化

秒杀业务优化思路？
- 利用redis完成库存余量、一人一单判断，完成抢单任务
- 再将下单业务放入阻塞队列，利用独立线程异步下单

基于阻塞队列异步秒杀存在哪些问题？
- 内存限制问题
- 数据安全问题

## 达人探店

### 点赞功能

需求：
- 同一个用户只能点赞一次，再次点击则取消点赞
- 如果当前用户已经点赞，则点赞按钮高亮显示（判断Blog类的isLike字段）

实现：
- 使用redis的set数据结构，key=blog:liked:blogId,值为已点赞用户结合
- 点击点赞按钮时先判断是否已经点赞，如果未点赞则点赞数+1，已点赞则点赞数-1

## 点赞排行榜

- 要求：有序、唯一
- 使用 sorted_set数据结构，`zscore key member` 可以判断元素是否存在

注意：数据库查询如 `select * from tb_user where user_id in (1010, 1);` 返回结果不会按照 `(1010, 1)` 顺序给出！
- 解决 

## 共同关注

一个用户可以关注多人，也可以被多人关注（多对多），使用中间表 `tb_follow` 记录

共同关注实现：
- 在关注用户时，将 `sadd user:follow:userId `

## Feed流推送

- 拉取关注用户的笔记，按时间顺序获取笔记。因为最新的笔记需要优先展示，所以需要倒序获取。
- 新发笔记会插入到开头，导致传统分页模式无法满足需求。如使用list保存笔记id，通过``

- 请求方法：GET
- 请求路径：/blog/of/follow
- 请求参数：lastId：上一次查询的最小时间戳，offset：偏移量
- 返回值：List<Blog>：小于指定时间戳的笔记集合，minTime：本次查询的推送的最小时间戳，offset：偏移量（本次查询中score最小的相同笔记数量）

